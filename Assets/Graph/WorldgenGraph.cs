using System;
using System.Collections.Generic;
using UnityEngine;

public enum NodeInputConstraint
{
    Any = 1 << 0,
    Exact = 1 << 1,
    Number = 1 << 2,
    Vector = 1 << 3,
    Texture = 1 << 4,
    // and so on.
    
    // TODO: Something a lot more flexible. I want people to be able to 
    // define their own type fields (e.g. structs, custom data types, etc)
    // and handle the IsCompatibleWith() and coloring themselves.
}

public static class NodeInputConstraintExtension
{
    // TODO: to/from a Type ? Plus stringifying for theming individual nodes. 
    // Can people extend constraints to new types?

    /// <summary>
    /// Retrieve the CSS style name from a type
    /// </summary>
    /// <returns></returns>
    public static string GetStyleName(this NodeInputConstraint type)
    {
        return type.ToString();
    }
}

[AttributeUsage(AttributeTargets.Field, AllowMultiple = true)]
public class InputAttribute : Attribute
{
    /// <summary>
    /// Custom name to override the default autogenerated one
    /// </summary>
    public string Name;

    /// <summary>
    /// Allow multiple edges to this output
    /// </summary>
    public bool AllowMultiple;

    /// <summary>
    /// Allowable output types to this input
    /// </summary>
    public NodeInputConstraint InputConstraint;

    public InputAttribute(
        NodeInputConstraint inputConstraint = NodeInputConstraint.Exact
    ) {
        AllowMultiple = true;
        InputConstraint = inputConstraint;
    }
}

[AttributeUsage(AttributeTargets.Field, AllowMultiple = true)]
public class OutputAttribute : Attribute
{
    /// <summary>
    /// Custom name to override the default autogenerated one
    /// </summary>
    public string Name;

    /// <summary>
    /// Allow multiple edges to this output
    /// </summary>
    public bool AllowMultiple;
    
    public OutputAttribute()
    {
        AllowMultiple = true;
    }
}
    
[AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
public class GraphNodeAttribute : Attribute
{
    public string Name;
    public Color HeaderTheme;

    public GraphNodeAttribute(string name)
    {
        Name = name;
        HeaderTheme = Color.black;
    }
}

[Serializable]
public class SerializedNode
{
    public string NodeType;
    public string Json;
}

[Serializable]
public class SerializedEdge
{
    public string OutputNodeGuid;
    public string OutputPortName;

    public string InputNodeGuid;
    public string InputPortName;
}

[Serializable]
public class SerializableGraph : ISerializationCallbackReceiver
{
    // Container that can be (de)serialized from JSON
    public string Name;
    
    [NonSerialized]
    public Dictionary<string, AbstractNode> Nodes = new Dictionary<string, AbstractNode>();
    
    [SerializeField]
    public List<SerializedNode> SerializedNodes = new List<SerializedNode>();
    
    [SerializeField]
    public List<SerializedEdge> SerializedEdges = new List<SerializedEdge>();
    // TODO: Not public. I just want the list for GraphViewElement.Load

    public void OnAfterDeserialize()
    {
        Debug.Log("serializable graph after deserialize");
        
        Nodes.Clear();
        foreach (var node in SerializedNodes)
        {
            // TODO: Type.GetType is too flimsy
            var instance = JsonUtility.FromJson(node.Json, Type.GetType(node.NodeType)) as AbstractNode;
            Nodes[instance.guid.ToString()] = instance;
        }

        // Connect ports of each node via edge data
        foreach (var edge in SerializedEdges)
        {
            Nodes.TryGetValue(edge.InputNodeGuid, out AbstractNode input);
            Nodes.TryGetValue(edge.OutputNodeGuid, out AbstractNode output);

            if (input == null || output == null)
            {
                // TODO: Better errors, etc
                Debug.LogError("Cannot load edge: missing nodes");
                continue;
            }
            
            var inputNodePort = input.GetInputPort(edge.InputPortName);
            var outputNodePort = output.GetOutputPort(edge.OutputPortName);

            if (inputNodePort == null || outputNodePort == null)
            {
                Debug.LogError("Cannot load edge: Missing named ports");
                continue;
            }

            inputNodePort.Connections.Add(new NodePortConnection() {
                Node = output,
                PortName = edge.OutputPortName
            });
            
            outputNodePort.Connections.Add(new NodePortConnection() {
                Node = input,
                PortName = edge.InputPortName
            });
        }
    }

    public void OnBeforeSerialize()
    {
        // NOTE: This is called CONSTANTLY if the graph is in the inspector.
        // Because the UI is constantly serializing to render a SerializedObject
        // Performance here will suffer with a big node list. 

        // Debug.Log("serializable graph before serialize");

        SerializedNodes.Clear();
        SerializedEdges.Clear();

        foreach (var node in Nodes.Values)
        {
            SerializedNodes.Add(new SerializedNode() {
                NodeType = node.GetType().Name,
                Json = JsonUtility.ToJson(node)
            });

            foreach (var port in node.Ports)
            {
                // Only serialize what's connected to input ports. We can 
                // reconstruct the bidirectional connection after deserialization
                if (port.PortType == PortType.Input)
                {
                    foreach (var connection in port.Connections)
                    {
                        SerializedEdges.Add(new SerializedEdge() {
                            InputNodeGuid = node.guid.ToString(),
                            InputPortName = port.Name,
                            OutputPortName = connection.PortName,
                            OutputNodeGuid = connection.Node.guid.ToString(),
                        });
                    }
                }
            }
        }
    }
}

[CreateAssetMenu]
public class WorldgenGraph : ScriptableObject
{
    public SerializableGraph graph;
}
